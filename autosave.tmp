import tkinter as tk
from tkinter import ttk, filedialog, messagebox, font, colorchooser, simpledialog, Toplevel
import sys
import threading
import datetime
import time
import os
import re

# --- ROBUST IMPORT SECTION ---
# The app will not crash if a library is missing; it will just disable that feature.
try:
    from docx import Document
    from docx.shared import Pt, RGBColor
    HAS_DOCX = True
except ImportError:
    HAS_DOCX = False

try:
    from PIL import Image, ImageTk
    HAS_PIL = True
except ImportError:
    HAS_PIL = False

try:
    import fitz  # PyMuPDF
    HAS_FITZ = True
except ImportError:
    HAS_FITZ = False

try:
    import pyttsx3
    HAS_TTS = True
except ImportError:
    HAS_TTS = False

try:
    from fpdf import FPDF
    HAS_FPDF = True
except ImportError:
    HAS_FPDF = False

try:
    from spellchecker import SpellChecker
    HAS_SPELL = True
except ImportError:
    HAS_SPELL = False

# --- CONFIGURATION & ASSETS ---
CONFIG = {
    "app_name": "PyWord MAX",
    "version": "3.0.1",
    "default_font": "Calibri",
    "default_size": 11,
}

THEME = {
    "light": {
        "bg": "#d4d4d4",           # Outer background (Desk)
        "ribbon": "#f0f0f0",       # Top Ribbon
        "paper": "#ffffff",        # Editor Page
        "text": "#000000",
        "btn_bg": "#e1e1e1",
        "btn_fg": "#000000",
        "accent": "#2b579a",       # Word Blue
        "status": "#2b579a"
    },
    "dark": {
        "bg": "#1e1e1e",
        "ribbon": "#2d2d2d",
        "paper": "#3c3c3c",
        "text": "#e0e0e0",
        "btn_bg": "#444444",
        "btn_fg": "#ffffff",
        "accent": "#007acc",
        "status": "#007acc"
    }
}

# --- HELPER CLASSES ---

class ToolTip:
    """Creates a pop-up description when hovering over buttons."""
    def __init__(self, widget, text):
        self.widget = widget
        self.text = text
        self.tip_window = None
        widget.bind("<Enter>", self.show_tip)
        widget.bind("<Leave>", self.hide_tip)

    def show_tip(self, event=None):
        try:
            x, y, _, _ = self.widget.bbox("insert")
            x += self.widget.winfo_rootx() + 25
            y += self.widget.winfo_rooty() + 25
            self.tip_window = tw = Toplevel(self.widget)
            tw.wm_overrideredirect(True)
            tw.wm_geometry(f"+{x}+{y}")
            label = tk.Label(tw, text=self.text, justify=tk.LEFT,
                             background="#ffffe0", relief=tk.SOLID, borderwidth=1,
                             font=("tahoma", "8", "normal"))
            label.pack(ipadx=1)
        except: pass

    def hide_tip(self, event=None):
        if self.tip_window:
            self.tip_window.destroy()
            self.tip_window = None

# --- MAIN APPLICATION CLASS ---

class PyWordMax:
    def __init__(self, root):
        self.root = root
        self.root.title(f"{CONFIG['app_name']} v{CONFIG['version']}")
        self.root.geometry("1400x900")
        
        # State Variables
        self.current_theme = "light"
        self.file_path = None
        self.saved = True
        self.zoom_level = 100
        self.format_painter_style = None # Stores style to copy
        self.images = [] # Prevent Garbage Collection
        
        # Initialize Services
        self.spell = SpellChecker() if HAS_SPELL else None
        self.tts_engine = pyttsx3.init() if HAS_TTS else None

        # Build UI
        self._init_styles()
        self._setup_layout()
        self._bind_events()
        self._start_autosave()
        
        # Initial stats update
        self._update_status_bar()

    def _init_styles(self):
        style = ttk.Style()
        style.theme_use('clam')
        style.configure("TNotebook", background=THEME[self.current_theme]["ribbon"])
        style.configure("TNotebook.Tab", padding=[12, 5], font=("Segoe UI", 9))

    def _setup_layout(self):
        # 1. Main Container
        self.main_container = tk.Frame(self.root, bg=THEME["light"]["bg"])
        self.main_container.pack(fill=tk.BOTH, expand=True)

        # 2. The Ribbon Container (Created first for layout, filled later)
        self.ribbon_frame = tk.Frame(self.main_container, bg=THEME["light"]["ribbon"], height=160, bd=1, relief=tk.RAISED)
        self.ribbon_frame.pack(side=tk.TOP, fill=tk.X)
        self.ribbon_frame.pack_propagate(False)

        # File Button
        self.btn_file = tk.Button(self.ribbon_frame, text="FILE", bg=THEME["light"]["accent"], fg="black",
                                  font=("Segoe UI", 10, "bold"), relief=tk.RAISED, bd=3,
                                  command=self._open_backstage)
        self.btn_file.pack(side=tk.LEFT, fill=tk.Y, padx=(0, 2))

        # Tabs Container
        self.tabs = ttk.Notebook(self.ribbon_frame)
        self.tabs.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        # 3. The Workspace (Status + Desk + Editor)
        # We must create the EDITOR before building the tabs, because the tabs reference the editor.
        
        self.workspace = tk.Frame(self.main_container, bg=THEME["light"]["bg"])
        self.workspace.pack(fill=tk.BOTH, expand=True)

        # Status Bar (Bottom)
        self.status_bar = tk.Frame(self.root, bg=THEME["light"]["status"], height=30)
        self.status_bar.pack(side=tk.BOTTOM, fill=tk.X)
        
        self.lbl_status = tk.Label(self.status_bar, text="Ready", bg=THEME["light"]["status"], fg="white", font=("Segoe UI", 9))
        self.lbl_status.pack(side=tk.LEFT, padx=10)
        
        self.lbl_details = tk.Label(self.status_bar, text="Ln 1, Col 0 | 0 Words", bg=THEME["light"]["status"], fg="#ddd", font=("Segoe UI", 9))
        self.lbl_details.pack(side=tk.LEFT, padx=10)

        # Desk (Holds the 'paper')
        self.desk_frame = tk.Frame(self.workspace, bg=THEME["light"]["bg"])
        self.desk_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)

        # Scrollbar
        self.v_scroll = tk.Scrollbar(self.desk_frame, orient=tk.VERTICAL)
        self.v_scroll.pack(side=tk.RIGHT, fill=tk.Y)

        # The "Paper" Editor
        self.page_border = tk.Frame(self.desk_frame, bg="#888", bd=1)
        self.page_border.pack(fill=tk.BOTH, expand=True, padx=50) 

        self.editor = tk.Text(self.page_border, font=(CONFIG["default_font"], CONFIG["default_size"]),
                              bg="white", fg="black", wrap=tk.WORD,
                              undo=True, selectbackground="#b3d4fc",
                              padx=60, pady=60, 
                              bd=0, spacing1=2, spacing2=2,
                              yscrollcommand=self.v_scroll.set)
        self.editor.pack(fill=tk.BOTH, expand=True)
        self.v_scroll.config(command=self.editor.yview)

        # Tags for highlighting
        self.editor.tag_configure("highlight_find", background="yellow", foreground="black")
        self.editor.tag_configure("error_spell", underline=True, underlinefg="red")

        # 4. NOW BUILD THE TABS (Safe because self.editor exists)
        self._build_tab_home()
        self._build_tab_insert()
        self._build_tab_layout()
        self._build_tab_review()
        self._build_tab_view()
        self._build_tab_help()

    # --- RIBBON BUILDERS (3D BUTTONS) ---
    def _create_group(self, parent, text):
        frame = tk.LabelFrame(parent, text=text, bg=THEME["light"]["ribbon"], fg="#555",
                              font=("Segoe UI", 8), padx=5, pady=5)
        frame.pack(side=tk.LEFT, fill=tk.Y, padx=5, pady=5)
        return frame

    def _3d_btn(self, parent, text, cmd, icon=None, width=None, tooltip=""):
        # Creates a button with relief=RAISED for the requested 3D look
        btn = tk.Button(parent, text=text, command=cmd, 
                        bg="#f0f0f0", activebackground="#e0e0e0",
                        relief=tk.RAISED, bd=3, font=("Segoe UI", 9))
        if width: btn.config(width=width)
        btn.pack(side=tk.LEFT, padx=2, fill=tk.Y)
        if tooltip: ToolTip(btn, tooltip)
        return btn

    def _build_tab_home(self):
        tab = tk.Frame(self.tabs, bg=THEME["light"]["ribbon"])
        self.tabs.add(tab, text="  Home  ")

        # Undo/Redo/Clipboard
        g_edit = self._create_group(tab, "Edit")
        self._3d_btn(g_edit, "‚Æå Undo", self.editor.edit_undo, tooltip="Ctrl+Z")
        self._3d_btn(g_edit, "‚Æé Redo", self.editor.edit_redo, tooltip="Ctrl+Y")
        self._3d_btn(g_edit, "üìã Paste", lambda: self.editor.event_generate("<<Paste>>"))
        self._3d_btn(g_edit, "üñå Paint", self._format_painter, tooltip="Copy Formatting")

        # Font Formatting
        g_font = self._create_group(tab, "Font")
        
        # Combos
        f_top = tk.Frame(g_font, bg=THEME["light"]["ribbon"])
        f_top.pack(side=tk.TOP, fill=tk.X)
        self.cb_font = ttk.Combobox(f_top, values=font.families(), width=15, state="readonly")
        self.cb_font.set(CONFIG["default_font"])
        self.cb_font.pack(side=tk.LEFT, padx=2)
        self.cb_font.bind("<<ComboboxSelected>>", self._apply_font_family)
        
        self.cb_size = ttk.Combobox(f_top, values=[8,9,10,11,12,14,16,18,24,36,48,72], width=3, state="readonly")
        self.cb_size.set(CONFIG["default_size"])
        self.cb_size.pack(side=tk.LEFT)
        self.cb_size.bind("<<ComboboxSelected>>", self._apply_font_size)

        f_bot = tk.Frame(g_font, bg=THEME["light"]["ribbon"])
        f_bot.pack(side=tk.TOP, pady=2)
        self._3d_btn(f_bot, "B", lambda: self._toggle_format("bold"), width=2)
        self._3d_btn(f_bot, "I", lambda: self._toggle_format("italic"), width=2)
        self._3d_btn(f_bot, "U", lambda: self._toggle_format("underline"), width=2)
        self._3d_btn(f_bot, "üé®", self._pick_color, tooltip="Text Color")

        # Paragraph
        g_para = self._create_group(tab, "Paragraph")
        self._3d_btn(g_para, "Left", lambda: self._align("left"))
        self._3d_btn(g_para, "Center", lambda: self._align("center"))
        self._3d_btn(g_para, "Right", lambda: self._align("right"))
        self._3d_btn(g_para, "‚Ä¢ List", self._insert_bullet)

        # Tools
        g_tools = self._create_group(tab, "Tools")
        self._3d_btn(g_tools, "üîç Find", self._open_find_tool)
        self._3d_btn(g_tools, "üìä Stats", self._show_stats)

    def _build_tab_insert(self):
        tab = tk.Frame(self.tabs, bg=THEME["light"]["ribbon"])
        self.tabs.add(tab, text="  Insert  ")
        
        g_media = self._create_group(tab, "Media")
        self._3d_btn(g_media, "üñº Image", self._insert_image)
        self._3d_btn(g_media, "üìÑ PDF Text", self._import_pdf)
        
        g_txt = self._create_group(tab, "Text")
        self._3d_btn(g_txt, "üìÖ Date", lambda: self.editor.insert(tk.INSERT, datetime.datetime.now().strftime("%Y-%m-%d")))
        self._3d_btn(g_txt, "üïí Time", lambda: self.editor.insert(tk.INSERT, datetime.datetime.now().strftime("%H:%M")))
        self._3d_btn(g_txt, "Œ© Symbol", self._open_symbol_picker)
        
        g_layout = self._create_group(tab, "Tables")
        self._3d_btn(g_layout, "‚äû Grid", self._insert_simple_table)

    def _build_tab_layout(self):
        tab = tk.Frame(self.tabs, bg=THEME["light"]["ribbon"])
        self.tabs.add(tab, text="  Layout  ")
        
        g_page = self._create_group(tab, "Page Setup")
        self._3d_btn(g_page, "Margins", self._set_margins)
        self._3d_btn(g_page, "Background", self._set_page_color)
        
        g_space = self._create_group(tab, "Spacing")
        self._3d_btn(g_space, "1.0", lambda: self.editor.config(spacing1=0, spacing2=0, spacing3=0))
        self._3d_btn(g_space, "1.5", lambda: self.editor.config(spacing1=5, spacing2=5, spacing3=5))
        self._3d_btn(g_space, "2.0", lambda: self.editor.config(spacing1=10, spacing2=10, spacing3=10))

    def _build_tab_review(self):
        tab = tk.Frame(self.tabs, bg=THEME["light"]["ribbon"])
        self.tabs.add(tab, text="  Review  ")
        
        g_proof = self._create_group(tab, "Proofing")
        self._3d_btn(g_proof, "ABC Check", self._run_spell_check)
        self._3d_btn(g_proof, "Word Count", self._show_stats)
        
        g_speech = self._create_group(tab, "Read Aloud")
        self._3d_btn(g_speech, "‚ñ∂ Play", self._tts_play)
        self._3d_btn(g_speech, "‚öô Settings", self._tts_settings)

    def _build_tab_view(self):
        tab = tk.Frame(self.tabs, bg=THEME["light"]["ribbon"])
        self.tabs.add(tab, text="  View  ")
        
        g_mode = self._create_group(tab, "Modes")
        self._3d_btn(g_mode, "üåì Light/Dark", self._toggle_theme)
        self._3d_btn(g_mode, "üî≤ Focus", self._toggle_focus_mode)
        
        g_zoom = self._create_group(tab, "Zoom")
        self._3d_btn(g_zoom, "‚ûï In", lambda: self._zoom(10))
        self._3d_btn(g_zoom, "‚ûñ Out", lambda: self._zoom(-10))
        self._3d_btn(g_zoom, "100%", lambda: self._zoom(0, reset=True))

    def _build_tab_help(self):
        tab = tk.Frame(self.tabs, bg=THEME["light"]["ribbon"])
        self.tabs.add(tab, text="  Help  ")
        g = self._create_group(tab, "Support")
        self._3d_btn(g, "‚ùì Help Guide", self._show_help_guide)
        self._3d_btn(g, "‚Ñπ About", lambda: messagebox.showinfo("About", f"{CONFIG['app_name']} v{CONFIG['version']}\nCreated with Python & Tkinter"))

    def _bind_events(self):
        self.editor.bind("<KeyRelease>", self._on_key_release)
        self.editor.bind("<ButtonRelease-1>", self._update_status_bar)
        self.editor.bind("<Control-s>", lambda e: self._save_file())
        self.editor.bind("<Control-o>", lambda e: self._open_file())
        self.editor.bind("<Control-f>", lambda e: self._open_find_tool())
        self.root.protocol("WM_DELETE_WINDOW", self._on_close)

    # --- FEATURE LOGIC ---

    def _open_backstage(self):
        """A full-screen file menu"""
        top = Toplevel(self.root)
        top.title("File Menu")
        top.state("zoomed")
        top.configure(bg="#333")

        # Sidebar
        sidebar = tk.Frame(top, bg="#1e1e1e", width=300)
        sidebar.pack(side=tk.LEFT, fill=tk.Y)
        
        tk.Label(sidebar, text="PyWord", font=("Segoe UI", 36, "bold"), fg="white", bg="#1e1e1e").pack(pady=50)

        def make_menu_btn(txt, cmd):
            tk.Button(sidebar, text=txt, font=("Segoe UI", 16), bg="#1e1e1e", fg="white", 
                      bd=0, activebackground="#444", activeforeground="white", cursor="hand2",
                      command=lambda: [cmd(), top.destroy()]).pack(fill=tk.X, pady=5, padx=20)

        make_menu_btn("New Document", self._new_file)
        make_menu_btn("Open...", self._open_file)
        make_menu_btn("Save", self._save_file)
        make_menu_btn("Export to PDF", self._export_pdf)
        make_menu_btn("Return to Editor", lambda: None)
        make_menu_btn("Exit", self._on_close)

    def _format_painter(self):
        """Copies font tags from current selection to buffer"""
        try:
            tags = self.editor.tag_names("insert")
            # Filter for our styling tags
            valid_styles = [t for t in tags if t in ["bold", "italic", "underline"] or t.startswith("font_") or t.startswith("color_")]
            
            if not self.format_painter_style:
                self.format_painter_style = valid_styles
                messagebox.showinfo("Format Painter", "Style Copied! Select text to apply.")
                self.editor.bind("<ButtonRelease-1>", self._apply_painter)
            else:
                self.format_painter_style = None
                self.editor.unbind("<ButtonRelease-1>")
        except: pass

    def _apply_painter(self, event):
        if self.format_painter_style:
            try:
                for tag in self.format_painter_style:
                    self.editor.tag_add(tag, "sel.first", "sel.last")
                # Clean up
                self.format_painter_style = None
                self.editor.unbind("<ButtonRelease-1>")
                messagebox.showinfo("Format Painter", "Style Applied.")
            except: pass

    def _open_symbol_picker(self):
        win = Toplevel(self.root)
        win.title("Symbols")
        win.geometry("400x400")
        
        symbols = [
            "¬©", "¬Æ", "‚Ñ¢", "‚Ç¨", "¬£", "¬•", "¬¢", "¬ß", "¬∂", "‚àû", "‚â†", "‚âà", "¬±", "‚â§", "‚â•",
            "√∑", "√ó", "¬∞", "¬µ", "Œ±", "Œ≤", "œÄ", "Œ©", "Œ£", "‚Üê", "‚Üë", "‚Üí", "‚Üì", "‚òÖ", "‚ò∫"
        ]
        
        r, c = 0, 0
        for s in symbols:
            b = tk.Button(win, text=s, font=("Segoe UI", 14), width=4, 
                          command=lambda char=s: [self.editor.insert(tk.INSERT, char), win.destroy()])
            b.grid(row=r, column=c, padx=2, pady=2)
            c += 1
            if c > 5:
                c = 0
                r += 1

    def _open_find_tool(self):
        win = Toplevel(self.root)
        win.title("Find & Replace")
        win.geometry("350x220")
        win.resizable(False, False)
        win.transient(self.root) # Keep on top

        tk.Label(win, text="Find what:").pack(pady=(10,0))
        e_find = tk.Entry(win, width=40)
        e_find.pack(pady=5)
        e_find.focus_set()

        tk.Label(win, text="Replace with:").pack(pady=(10,0))
        e_rep = tk.Entry(win, width=40)
        e_rep.pack(pady=5)

        def do_find():
            self.editor.tag_remove("highlight_find", "1.0", tk.END)
            s = e_find.get()
            if s:
                idx = "1.0"
                while True:
                    idx = self.editor.search(s, idx, nocase=1, stopindex=tk.END)
                    if not idx: break
                    lastidx = f"{idx}+{len(s)}c"
                    self.editor.tag_add("highlight_find", idx, lastidx)
                    idx = lastidx
                # Scroll to first
                ranges = self.editor.tag_ranges("highlight_find")
                if ranges: self.editor.see(ranges[0])

        def do_replace():
            s = e_find.get()
            r = e_rep.get()
            if not s: return
            # Simple replace all logic
            data = self.editor.get("1.0", tk.END)
            if s in data:
                newdata = data.replace(s, r)
                self.editor.delete("1.0", tk.END)
                self.editor.insert("1.0", newdata)
                messagebox.showinfo("Result", "Replacement Complete.")

        f_btns = tk.Frame(win)
        f_btns.pack(pady=15)
        tk.Button(f_btns, text="Highlight All", command=do_find).pack(side=tk.LEFT, padx=5)
        tk.Button(f_btns, text="Replace All", command=do_replace).pack(side=tk.LEFT, padx=5)

    def _show_stats(self):
        text = self.editor.get("1.0", tk.END)
        words = len(text.split())
        chars = len(text) - 1 # Remove trailing newline
        lines = int(self.editor.index('end-1c').split('.')[0])
        # Avg reading speed 200 wpm
        read_time = round(words / 200, 2)
        
        msg = f"""DOCUMENT STATISTICS
-------------------
Words: {words}
Characters: {chars}
Lines: {lines}

Est. Reading Time: {read_time} min
        """
        messagebox.showinfo("Statistics", msg)

    # --- TEXT MANIPULATION ---
    
    def _apply_font_family(self, event=None):
        f = self.cb_font.get()
        self._tag_selection(f"font_fam_{f}", font=(f, CONFIG["default_size"]))

    def _apply_font_size(self, event=None):
        s = self.cb_size.get()
        f = self.cb_font.get()
        self._tag_selection(f"font_size_{s}", font=(f, s))

    def _toggle_format(self, tag_name):
        current_tags = self.editor.tag_names("insert")
        if tag_name in current_tags:
            self.editor.tag_remove(tag_name, "sel.first", "sel.last")
        else:
            self.editor.tag_add(tag_name, "sel.first", "sel.last")
            # Configure style if not exists
            actual_font = font.Font(font=self.editor.cget("font"))
            if tag_name == "bold": actual_font.configure(weight="bold")
            if tag_name == "italic": actual_font.configure(slant="italic")
            if tag_name == "underline": actual_font.configure(underline=True)
            self.editor.tag_configure(tag_name, font=actual_font)

    def _tag_selection(self, tag_name, **kwargs):
        # Helper to apply tags to selection, or handle no selection
        try:
            self.editor.tag_add(tag_name, "sel.first", "sel.last")
            self.editor.tag_configure(tag_name, **kwargs)
        except tk.TclError:
            pass # No selection

    def _pick_color(self):
        c = colorchooser.askcolor()[1]
        if c: self._tag_selection(f"color_{c}", foreground=c)

    def _align(self, align):
        self.editor.tag_configure(align, justify=align)
        try:
            self.editor.tag_add(align, "sel.first", "sel.last")
        except:
            self.editor.tag_add(align, "insert linestart", "insert lineend")

    def _insert_bullet(self):
        self.editor.insert(tk.INSERT, "\n ‚Ä¢ ")

    def _insert_image(self):
        if not HAS_PIL:
            messagebox.showerror("Error", "Pillow library missing.")
            return
        path = filedialog.askopenfilename(filetypes=[("Images", "*.png;*.jpg;*.jpeg")])
        if path:
            img = Image.open(path)
            img.thumbnail((300, 300)) # Resize for editor
            photo = ImageTk.PhotoImage(img)
            self.images.append(photo)
            self.editor.image_create(tk.INSERT, image=photo, padx=10, pady=10)

    def _insert_simple_table(self):
        # Simulates a table using grid entries in a window
        f = tk.Frame(self.editor, bg="gray")
        for r in range(3):
            for c in range(3):
                e = tk.Entry(f, width=12, relief=tk.SOLID)
                e.grid(row=r, column=c, padx=1, pady=1)
        self.editor.window_create(tk.INSERT, window=f, padx=10, pady=10)

    # --- FILE I/O ---

    def _new_file(self):
        if messagebox.askyesno("New File", "Unsaved changes will be lost. Continue?"):
            self.editor.delete("1.0", tk.END)
            self.file_path = None
            self.root.title(CONFIG["app_name"])

    def _save_file(self):
        if not self.file_path:
            self.file_path = filedialog.asksaveasfilename(defaultextension=".txt", 
                filetypes=[("Text File", "*.txt"), ("Word Document", "*.docx")])
        
        if self.file_path:
            if self.file_path.endswith(".docx") and HAS_DOCX:
                doc = Document()
                # Simple extraction: split by lines
                lines = self.editor.get("1.0", tk.END).split('\n')
                for line in lines:
                    doc.add_paragraph(line)
                doc.save(self.file_path)
            else:
                with open(self.file_path, "w", encoding="utf-8") as f:
                    f.write(self.editor.get("1.0", tk.END))
            
            self.saved = True
            self.root.title(f"{CONFIG['app_name']} - {os.path.basename(self.file_path)}")

    def _open_file(self):
        path = filedialog.askopenfilename(filetypes=[("Documents", "*.docx;*.txt;*.pdf")])
        if path:
            self.editor.delete("1.0", tk.END)
            self.file_path = path
            
            if path.endswith(".docx") and HAS_DOCX:
                doc = Document(path)
                text = "\n".join([p.text for p in doc.paragraphs])
                self.editor.insert(tk.END, text)
            elif path.endswith(".pdf") and HAS_FITZ:
                self._import_pdf(path)
                return # Skip standard load
            else:
                with open(path, "r", encoding="utf-8") as f:
                    self.editor.insert(tk.END, f.read())
            
            self.root.title(f"{CONFIG['app_name']} - {os.path.basename(path)}")

    def _import_pdf(self, path=None):
        if not HAS_FITZ: return
        if not path:
            path = filedialog.askopenfilename(filetypes=[("PDF", "*.pdf")])
        
        if path:
            doc = fitz.open(path)
            text = ""
            for page in doc:
                text += page.get_text()
            self.editor.insert(tk.INSERT, text)

    def _export_pdf(self):
        if not HAS_FPDF:
            messagebox.showerror("Error", "FPDF library missing.")
            return
        path = filedialog.asksaveasfilename(defaultextension=".pdf")
        if path:
            pdf = FPDF()
            pdf.add_page()
            pdf.set_font("Arial", size=12)
            # Encoding fix for FPDF standard
            txt = self.editor.get("1.0", tk.END).encode('latin-1', 'replace').decode('latin-1')
            pdf.multi_cell(0, 10, txt)
            pdf.output(path)
            messagebox.showinfo("Export", "PDF Exported Successfully.")

    # --- ADVANCED FEATURES ---

    def _run_spell_check(self):
        if not HAS_SPELL:
            messagebox.showerror("Error", "pyspellchecker missing.")
            return
        
        self.editor.tag_remove("error_spell", "1.0", tk.END)
        text = self.editor.get("1.0", tk.END)
        words = text.split()
        misspelled = self.spell.unknown(words)
        
        if not misspelled:
            messagebox.showinfo("Spell Check", "No errors found.")
            return

        # Simple highlighting
        for word in misspelled:
            idx = "1.0"
            while True:
                idx = self.editor.search(word, idx, stopindex=tk.END)
                if not idx: break
                lastidx = f"{idx}+{len(word)}c"
                self.editor.tag_add("error_spell", idx, lastidx)
                idx = lastidx
        
        messagebox.showinfo("Spell Check", f"Found {len(misspelled)} potential errors (Underlined red).")

    def _tts_play(self):
        if not HAS_TTS: return
        text = self.editor.get(tk.INSERT, tk.END)
        if not text.strip(): text = self.editor.get("1.0", tk.END)
        self.tts_engine.say(text)
        self.tts_engine.runAndWait()

    def _tts_settings(self):
        if not HAS_TTS: return
        # Simple popup to change rate
        r = simpledialog.askinteger("Speed", "Reading Speed (Default 200):", minvalue=50, maxvalue=400)
        if r: self.tts_engine.setProperty('rate', r)

    def _show_help_guide(self):
        win = Toplevel(self.root)
        win.title("Help Guide")
        win.geometry("600x500")
        
        notebook = ttk.Notebook(win)
        notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Guide Content
        def add_page(title, content):
            f = tk.Frame(notebook, bg="white")
            notebook.add(f, text=title)
            t = tk.Text(f, wrap=tk.WORD, font=("Segoe UI", 10), padx=20, pady=20, bg="white", bd=0)
            t.insert("1.0", content)
            t.config(state="disabled")
            t.pack(fill=tk.BOTH, expand=True)

        intro = """
        WELCOME TO PYWORD MAX
        
        A robust word processor built with Python.
        
        GETTING STARTED:
        1. Type text in the main area.
        2. Use the 'Home' tab to format text (Bold, Italic, Color).
        3. Use 'Insert' to add Images or Tables.
        4. Save your work via the 'File' menu.
        """
        
        shortcuts = """
        KEYBOARD SHORTCUTS:
        
        Ctrl+S  : Save File
        Ctrl+O  : Open File
        Ctrl+F  : Find & Replace
        Ctrl+Z  : Undo
        Ctrl+Y  : Redo
        Ctrl+B  : Bold (if selected)
        """
        
        features = """
        ADVANCED FEATURES:
        
        ‚Ä¢ PDF Import: Extract text directly from PDF files.
        ‚Ä¢ Text-to-Speech: Listen to your document in the Review tab.
        ‚Ä¢ Focus Mode: Remove distractions.
        ‚Ä¢ Format Painter: Copy styles from one word to another.
        """
        
        add_page("Welcome", intro)
        add_page("Shortcuts", shortcuts)
        add_page("Features", features)

    # --- UI UTILS ---

    def _update_status_bar(self, event=None):
        # Updates Line/Col and Word Count
        idx = self.editor.index(tk.INSERT)
        line, col = idx.split('.')
        words = len(self.editor.get("1.0", tk.END).split())
        self.lbl_details.config(text=f"Ln {line}, Col {col} | {words} Words")

    def _on_key_release(self, event):
        self._update_status_bar()
        self.saved = False

    def _zoom(self, amount, reset=False):
        if reset: self.zoom_level = 100
        else: self.zoom_level += amount
        
        # Limit
        if self.zoom_level < 50: self.zoom_level = 50
        if self.zoom_level > 200: self.zoom_level = 200
        
        # Calculation
        new_size = int((CONFIG["default_size"] * self.zoom_level) / 100)
        new_font = (CONFIG["default_font"], new_size)
        self.editor.configure(font=new_font)
        
        # Scale padding
        new_pad = int(60 * (self.zoom_level / 100))
        self.editor.configure(padx=new_pad)

    def _set_margins(self):
        m = simpledialog.askinteger("Margins", "Padding (px):", minvalue=0, maxvalue=300)
        if m is not None:
            self.editor.config(padx=m, pady=m)

    def _set_page_color(self):
        c = colorchooser.askcolor()[1]
        if c: self.editor.config(bg=c)

    def _toggle_focus_mode(self):
        if self.ribbon_frame.winfo_viewable():
            self.ribbon_frame.pack_forget()
            self.status_bar.pack_forget()
            self.workspace.pack(expand=True, fill=tk.BOTH) # reclaim space
            messagebox.showinfo("Focus Mode", "Press Esc to exit Focus Mode", parent=self.root)
            self.root.bind("<Escape>", lambda e: self._toggle_focus_mode())
        else:
            self.workspace.pack_forget()
            self.ribbon_frame.pack(side=tk.TOP, fill=tk.X)
            self.workspace.pack(fill=tk.BOTH, expand=True)
            self.status_bar.pack(side=tk.BOTTOM, fill=tk.X)
            self.root.unbind("<Escape>")

    def _toggle_theme(self):
        self.current_theme = "dark" if self.current_theme == "light" else "light"
        t = THEME[self.current_theme]
        
        # Apply colors
        self.workspace.config(bg=t["bg"])
        self.desk_frame.config(bg=t["bg"])
        self.editor.config(bg=t["paper"], fg=t["text"], insertbackground=t["text"])
        self.ribbon_frame.config(bg=t["ribbon"])
        # Note: Ideally you iterate through all buttons to update them, 
        # but for this script size, we handle the main containers.

    def _start_autosave(self):
        def worker():
            while True:
                time.sleep(60)
                try:
                    with open("autosave_backup.tmp", "w", encoding="utf-8") as f:
                        f.write(self.editor.get("1.0", tk.END))
                except: pass
        t = threading.Thread(target=worker, daemon=True)
        t.start()

    def _on_close(self):
        if not self.saved:
            if not messagebox.askyesno("Exit", "You have unsaved changes. Exit anyway?"):
                return
        self.root.destroy()

if __name__ == "__main__":
    root = tk.Tk()
    app = PyWordMax(root)
    root.mainloop()
